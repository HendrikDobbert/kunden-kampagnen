<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KI-Pr√ºfungstrainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Library for parsing .docx files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- Library for parsing .pdf files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        // Configure the worker for pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .mic-active { animation: pulse 1.5s infinite; }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
        }
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            transition: opacity 0.2s ease-in-out;
        }
        .modal-content {
            background-color: white; padding: 2rem; border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); max-width: 90%; width: 500px;
            transform: scale(0.95); transition: transform 0.2s ease-in-out;
        }
        .modal-backdrop:not(.hidden) .modal-content {
            transform: scale(1);
        }
        .tab-btn.active-tab {
            border-color: #3b82f6; color: #3b82f6; border-bottom-width: 2px;
        }
        .tab-btn {
            padding: 0.5rem 1rem; border-bottom: 2px solid transparent;
            font-weight: 500; color: #64748b;
        }
        .tab-panel {
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Styles for collapsible module sections */
        details > summary {
            list-style: none;
            cursor: pointer;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
        details > summary::before {
            content: '‚ñ∫';
            margin-right: 0.5rem;
            display: inline-block;
            transition: transform 0.2s;
        }
        details[open] > summary::before {
            transform: rotate(90deg);
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">

    <div id="app-container" class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-blue-600">üß† KI-Pr√ºfungstrainer</h1>
            <p class="text-slate-500 mt-2">Dein adaptiver Lern-Coach mit Spaced Repetition</p>
        </header>

        <!-- Tabs -->
        <div id="main-tabs" class="mb-6 border-b border-slate-200">
            <nav class="flex space-x-2 sm:space-x-4" aria-label="Tabs">
                <button class="tab-btn active-tab" data-target="dashboard-panel">Dashboard</button>
                <button class="tab-btn" data-target="profile-panel">Profil</button>
                <button class="tab-btn" data-target="setup-panel">Neue Lerneinheit</button>
                <button class="tab-btn" data-target="questions-panel">Fragen & Dokumente</button>
            </nav>
        </div>

        <!-- ===== DASHBOARD PANEL ===== -->
        <div id="dashboard-panel" class="tab-panel">
            <h2 class="text-2xl font-semibold mb-4">Deine Lern-Statistik</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 text-center mb-8">
                <div class="bg-white p-4 rounded-lg shadow-md"><div class="text-3xl font-bold text-blue-700" id="db-total-time">0m</div><div class="text-slate-600">Gesamte Lernzeit</div></div>
                <div class="bg-white p-4 rounded-lg shadow-md"><div class="text-3xl font-bold text-green-700" id="db-total-questions">0</div><div class="text-slate-600">Fragen beantwortet</div></div>
                <div class="bg-white p-4 rounded-lg shadow-md"><div class="text-3xl font-bold text-yellow-700" id="db-avg-score">0.0</div><div class="text-slate-600">√ò Punkte</div></div>
                <div class="bg-white p-4 rounded-lg shadow-md"><div class="text-3xl font-bold text-red-700" id="db-total-followups">0</div><div class="text-slate-600">KI-Nachfragen</div></div>
            </div>
            
            <h3 class="text-xl font-semibold mb-3">Statistik nach Themen</h3>
            <div id="db-topic-stats" class="space-y-2 bg-white p-4 rounded-lg shadow-md mb-8"></div>

            <!-- NEW: SRS Progress Section -->
            <h3 class="text-xl font-semibold mb-3">Lernfortschritt (Spaced Repetition)</h3>
            <div id="db-srs-progress" class="space-y-4 bg-white p-4 rounded-lg shadow-md">
                <!-- Progress will be dynamically inserted here -->
            </div>
        </div>

        <!-- ===== PROFILE PANEL ===== -->
        <div id="profile-panel" class="tab-panel hidden">
            <h2 class="text-2xl font-semibold mb-4">Dein Skill-Profil</h2>
            <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="w-full max-w-lg mx-auto"><canvas id="skill-chart"></canvas></div>
                <div class="mt-6">
                    <button id="generate-analysis-btn" class="w-full bg-indigo-600 text-white px-6 py-3 rounded-md font-semibold hover:bg-indigo-700 transition-colors flex items-center justify-center">
                        <span class="btn-text">St√§rken & Schw√§chen analysieren</span>
                        <div class="loader btn-loader hidden w-5 h-5 border-2 border-white rounded-full"></div>
                    </button>
                </div>
                <div id="skill-analysis-output" class="mt-6 bg-slate-50 p-4 rounded-md hidden"></div>
            </div>
        </div>

        <!-- ===== SETUP PANEL (REFACTORED with SRS) ===== -->
        <div id="setup-panel" class="tab-panel hidden">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4">Neue Lerneinheit erstellen</h2>
                
                <!-- Spaced Repetition Section -->
                <div class="bg-blue-50 border-l-4 border-blue-500 p-4 rounded-r-lg mb-6">
                    <h3 class="text-lg font-semibold text-blue-800">Intelligentes Training (Spaced Repetition)</h3>
                    <p class="text-slate-600 text-sm mt-1 mb-3">
                        Das System merkt sich, welche Fragen du gut und welche du schlecht beantwortet hast. Schwierige Fragen werden dir dann automatisch fr√ºher und h√§ufiger wieder vorgelegt, bis sie sitzen. Das ist eine extrem effektive Lernmethode.
                    </p>
                    <button id="start-srs-session-btn" class="w-full bg-blue-600 text-white px-6 py-3 rounded-md font-semibold hover:bg-blue-700 transition-colors flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M4.5 12a7.5 7.5 0 0 1 15 0m-15 0a7.5 7.5 0 0 0 15 0"></path></svg>
                        Intelligentes Training starten (<span id="srs-due-count">0</span> f√§llige Fragen)
                    </button>
                </div>

                <div class="text-center my-4">
                    <span class="text-slate-400 font-semibold">ODER</span>
                </div>

                <!-- Manual Session Section -->
                <div class="space-y-4">
                    <h3 class="text-lg font-semibold text-slate-700">Manuelles Training</h3>
                    <div>
                        <label for="session-module" class="block text-sm font-medium text-slate-700 mb-1">1. Modul ausw√§hlen</label>
                        <select id="session-module" class="w-full p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500"></select>
                    </div>
                    <div>
                        <label for="session-topic" class="block text-sm font-medium text-slate-700 mb-1">2. Thema ausw√§hlen</label>
                        <select id="session-topic" class="w-full p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500"></select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-700 mb-1">3. Fragen f√ºr das Training ausw√§hlen</label>
                        <div id="session-question-selection" class="mt-2 p-3 border border-slate-300 rounded-md h-64 overflow-y-auto space-y-2 bg-slate-50">
                            <p class="text-slate-500">Bitte w√§hle zuerst ein Thema aus.</p>
                        </div>
                    </div>
                    <textarea id="session-context" rows="4" placeholder="F√ºge hier zus√§tzliche Notizen f√ºr diese Lerneinheit ein (optional)..." class="w-full p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500"></textarea>
                    <button id="start-session-btn" class="w-full bg-slate-700 text-white px-6 py-3 rounded-md font-semibold hover:bg-slate-800 transition-colors">Manuelles Training starten</button>
                </div>
            </div>
        </div>
        
        <!-- ===== QUESTIONS PANEL (REFACTORED) ===== -->
        <div id="questions-panel" class="tab-panel hidden">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <!-- Section for Adding New Questions -->
                <div id="add-question-section" class="mb-8 p-4 border border-slate-200 rounded-lg">
                    <h3 class="text-xl font-semibold mb-4">Neues Thema / Fragen hinzuf√ºgen</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="add-q-module" class="block text-sm font-medium text-slate-700 mb-1">Modul ausw√§hlen oder erstellen</label>
                            <select id="add-q-module" class="w-full p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500"></select>
                            <input type="text" id="add-q-new-module-input" placeholder="Neues Modul anlegen" class="hidden w-full mt-2 p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label for="add-q-topic" class="block text-sm font-medium text-slate-700 mb-1">Thema ausw√§hlen oder erstellen</label>
                            <select id="add-q-topic" class="w-full p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500"></select>
                            <input type="text" id="add-q-new-topic-input" placeholder="Neues Thema anlegen" class="hidden w-full mt-2 p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500">
                        </div>
                        <textarea id="add-q-textarea" rows="4" placeholder="F√ºge hier deine Fragen ein (eine pro Zeile)..." class="w-full p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500"></textarea>
                        <button id="add-questions-btn" class="w-full bg-blue-600 text-white px-6 py-3 rounded-md font-semibold hover:bg-blue-700 transition-colors">Speichern</button>
                    </div>
                </div>
                
                <!-- Existing Question Manager -->
                <h2 class="text-2xl font-semibold mb-4">Deine Themen- & Fragen-Datenbank</h2>
                <div id="question-manager" class="space-y-6">
                    <!-- Questions will be dynamically inserted here -->
                </div>
            </div>
        </div>

        <!-- ===== QUIZ PANEL ===== -->
        <div id="quiz-panel" class="hidden">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold" id="quiz-topic"></h2>
                    <div class="text-lg font-mono bg-slate-200 px-3 py-1 rounded">
                        Frage <span id="current-q-num"></span> / <span id="total-q-num"></span>
                    </div>
                </div>
                <div class="bg-slate-50 p-4 rounded-md mb-4">
                    <p class="text-lg font-medium" id="quiz-question"></p>
                </div>
                <textarea id="user-answer" rows="8" placeholder="Schreibe deine Antwort hier oder nutze die Diktierfunktion..." class="w-full p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500"></textarea>
                <div class="flex items-center justify-between mt-4">
                    <button id="speech-btn" class="p-3 bg-slate-200 rounded-full hover:bg-slate-300 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                    </button>
                    <div class="text-2xl font-bold text-blue-600" id="timer">00:00</div>
                    <button id="submit-answer-btn" class="bg-green-600 text-white px-6 py-3 rounded-md font-semibold hover:bg-green-700 transition-colors flex items-center justify-center min-w-[150px]">
                        <span class="btn-text">Antwort pr√ºfen</span>
                        <div class="loader btn-loader hidden w-5 h-5 border-2 border-white rounded-full"></div>
                    </button>
                </div>
            </div>
            <div id="feedback-container" class="mt-6 bg-white p-6 rounded-lg shadow-md hidden">
                <h3 class="text-xl font-semibold mb-3">KI-Bewertung</h3>
                <div id="feedback-content"></div>
                <button id="next-question-btn" class="mt-4 w-full bg-blue-600 text-white px-6 py-3 rounded-md font-semibold hover:bg-blue-700 transition-colors hidden">N√§chste Frage</button>
            </div>
        </div>

        <!-- ===== STATS PANEL ===== -->
        <div id="stats-panel" class="hidden">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4">Ergebnis: <span id="stats-topic"></span></h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center mb-6">
                    <div class="bg-blue-100 p-4 rounded-md"><div class="text-3xl font-bold text-blue-700" id="stats-score"></div><div class="text-slate-600">Gesamtpunkte</div></div>
                    <div class="bg-green-100 p-4 rounded-md"><div class="text-3xl font-bold text-green-700" id="stats-time"></div><div class="text-slate-600">Gesamtzeit</div></div>
                    <div class="bg-yellow-100 p-4 rounded-md"><div class="text-3xl font-bold text-yellow-700" id="stats-avg-score"></div><div class="text-slate-600">Punkte / Frage</div></div>
                </div>
                <h3 class="text-xl font-semibold mb-3">Detaillierte Auswertung</h3>
                <div id="stats-details" class="space-y-4"></div>
                <button id="back-to-start-btn" class="mt-6 w-full bg-slate-600 text-white px-6 py-3 rounded-md font-semibold hover:bg-slate-700 transition-colors">Zum Dashboard</button>
            </div>
        </div>
        
        <footer class="text-center mt-12 text-sm text-slate-400">
            <p>Angemeldet als: <span id="user-id-display" class="font-mono">...wird geladen...</span></p>
        </footer>
    </div>
    
    <div id="custom-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <div id="modal-header" class="flex justify-between items-center mb-4">
                <h3 id="modal-title" class="text-xl font-semibold">Mitteilung</h3>
                <button id="modal-close-btn" class="text-slate-500 hover:text-slate-800">&times;</button>
            </div>
            <div id="modal-body">
                 <p id="modal-text" class="mb-4"></p>
            </div>
            <div id="modal-footer" class="mt-4">
                <button id="modal-ok-btn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">OK</button>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Firebase SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, addDoc, updateDoc, deleteDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIG & INITIALIZATION ---
        // User-provided Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDA2pW52QXBfU17P6DWXqfUVVm4mPAIuqQ",
            authDomain: "sylvan-chess-418211.firebaseapp.com",
            projectId: "sylvan-chess-418211",
            storageBucket: "sylvan-chess-418211.appspot.com",
            messagingSenderId: "384756172708",
            appId: "1:384756172708:web:84caf479fca15c1831e331"
        };
        // User-provided Generative API Key
        const GEMINI_API_KEY = "AIzaSyAep_D8QeYlPSeZV_zkh0anfkZT-aXmxPA";
        
        // Firebase services
        let db, auth;

        // App state
        let userId;
        let unsubscribeFromSessions; // To detach the Firestore listener
        let currentSession = {};
        let allUserSessions = []; // This will be our local, real-time cache of Firestore data
        let timerInterval;
        let secondsElapsed = 0;
        let skillChartInstance = null;
        let recognition;
        let modulesAndTopics = {};

        // SRS Configuration: Intervals in days for each level
        const SRS_INTERVALS = [1, 3, 7, 14, 30, 90, 180, 365]; 

        const SKILL_LABELS = {
            factual_knowledge: "Faktenwissen",
            comprehension: "Verst√§ndnis",
            analysis_transfer: "Analyse/Transfer",
            argumentation: "Argumentation",
            precision: "Pr√§zision",
            completeness: "Vollst√§ndigkeit"
        };
        
        const panels = {
            dashboard: document.getElementById('dashboard-panel'),
            profile: document.getElementById('profile-panel'),
            setup: document.getElementById('setup-panel'),
            questions: document.getElementById('questions-panel'),
            quiz: document.getElementById('quiz-panel'),
            stats: document.getElementById('stats-panel'),
            modal: document.getElementById('custom-modal'),
            mainTabs: document.getElementById('main-tabs')
        };
        
        // --- INITIALIZE ---
        async function initializeAppAndAuth() {
            console.log("[LOG] initializeAppAndAuth: Starting application initialization.");
            addInitialEventListeners();
            setupSpeechRecognition();

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); // For easier debugging
                console.log("[LOG] initializeAppAndAuth: Firebase app initialized successfully.");

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        console.log(`[LOG] onAuthStateChanged: User is signed in with UID: ${user.uid}`);
                        userId = user.uid;
                        document.getElementById('user-id-display').textContent = userId;
                        loadDataFromFirestore();
                    } else {
                        console.warn("[LOG] onAuthStateChanged: No user signed in. Attempting to sign in anonymously...");
                        try {
                            await signInAnonymously(auth);
                            console.log("[LOG] onAuthStateChanged: Signed in anonymously successfully.");
                            // The onAuthStateChanged listener will fire again with the new user object.
                        } catch (error) {
                            console.error("[LOG] onAuthStateChanged: Error during anonymous sign-in:", error);
                            document.getElementById('user-id-display').textContent = "Anmeldefehler.";
                        }
                    }
                });
            } catch (error) {
                console.error("[LOG] initializeAppAndAuth: FATAL Error initializing Firebase:", error);
                document.getElementById('user-id-display').textContent = "Initialisierungsfehler.";
            }
             switchPanel('dashboard');
        }
        
        // --- DATA HANDLING (FIRESTORE) ---
        function loadDataFromFirestore() {
            console.log("[LOG] loadDataFromFirestore: Attempting to load data.");
            if (unsubscribeFromSessions) {
                console.log("[LOG] loadDataFromFirestore: Unsubscribing from previous Firestore listener.");
                unsubscribeFromSessions(); // Detach any old listener
            }

            if (!userId) {
                console.error("[LOG] loadDataFromFirestore: Cannot load data because userId is not set.");
                return;
            }
            
            const sessionsCollectionRef = collection(db, 'users', userId, 'sessions');
            console.log(`[LOG] loadDataFromFirestore: Attaching snapshot listener to collection 'users/${userId}/sessions'.`);

            unsubscribeFromSessions = onSnapshot(sessionsCollectionRef, (snapshot) => {
                console.log(`[LOG] onSnapshot: Received Firestore data update. Number of documents: ${snapshot.docs.length}.`);
                allUserSessions = snapshot.docs.map(doc => ({
                    id: doc.id, // <-- Store Firestore document ID
                    ...doc.data()
                }));
                console.log("[LOG] onSnapshot: Local cache 'allUserSessions' updated.", allUserSessions);
                updateAllDynamicContent();
            }, (error) => {
                console.error("[LOG] onSnapshot: Error fetching sessions from Firestore:", error);
                showModal("Fehler beim Laden der Daten aus der Datenbank. √úberpr√ºfen Sie Ihre Firestore-Sicherheitsregeln.");
            });
        }

        // --- GEMINI API HELPER (NOW LIVE) ---
        async function callGemini(prompt, type = 'analysis') {
            console.log(`[LOG] callGemini: Called with type '${type}'.`);
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            
            let fullPrompt = "";
            let generationConfig = {};

            if (type === 'feedback') {
                fullPrompt = `
                    You are an expert tutor. Evaluate the user's answer to the question based on the provided context.
                    Return ONLY a valid JSON string in the following format, with no other text or markdown formatting.
                    The feedback_html should be encouraging and constructive, using simple HTML tags like <p>, <h4>, <strong>.

                    JSON Schema:
                    {
                      "score": number (0-10),
                      "feedback_html": "string (HTML formatted feedback)",
                      "follow_up_question": "string (a relevant follow-up question or empty string)",
                      "skill_ratings": {
                        "factual_knowledge": number (0-10), "comprehension": number (0-10), "analysis_transfer": number (0-10),
                        "argumentation": number (0-10), "precision": number (0-10), "completeness": number (0-10)
                      }
                    }

                    Here is the data:
                    ${prompt}
                `;
                 generationConfig = { responseMimeType: "application/json" };
            } else { // 'analysis' type
                fullPrompt = `
                    You are an expert learning coach. Analyze the user's skill profile based on the provided data.
                    Provide an analysis of strengths and weaknesses, and give actionable tips for improvement.
                    Format your response using simple HTML tags like <h4>, <ul>, <li>, <strong>. Do not include <html> or <body> tags.
                    Use emojis to make it engaging.

                    Here is the data:
                    ${prompt}
                `;
            }

            const payload = {
                contents: [{ parts: [{ text: fullPrompt }] }],
                generationConfig: generationConfig
            };
            console.log("[LOG] callGemini: Sending payload to API:", payload);

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error("[LOG] callGemini: API Error Response Body:", errorBody);
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const result = await response.json();
                console.log("[LOG] callGemini: Received raw API response:", result);
                if (!result.candidates || !result.candidates[0].content.parts[0].text) {
                    throw new Error("Invalid response structure from API");
                }
                const responseText = result.candidates[0].content.parts[0].text;
                console.log("[LOG] callGemini: Extracted response text:", responseText);
                return responseText;
            } catch (error) {
                console.error('[LOG] callGemini: Error calling Gemini API:', error);
                throw error;
            }
        }


        // --- UI & STATE MANAGEMENT ---
        function switchPanel(panelName) {
            console.log(`[LOG] switchPanel: Switching to panel '${panelName}'.`);
            Object.values(panels).forEach(p => { if(p) p.classList.add('hidden'); });
            
            if (panels[panelName]) {
                panels[panelName].classList.remove('hidden');
            } else {
                 console.warn(`[LOG] switchPanel: Panel '${panelName}' not found.`);
            }

            if (['dashboard', 'profile', 'setup', 'questions'].includes(panelName)) {
                panels.mainTabs.classList.remove('hidden');
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.toggle('active-tab', btn.dataset.target === `${panelName}-panel`);
                });
            } else {
                panels.mainTabs.classList.add('hidden');
            }
        }
        
        function updateAllDynamicContent() {
            console.log("[LOG] updateAllDynamicContent: Starting full UI refresh based on local data.");
            calculateAndDisplayDashboardStats(allUserSessions);
            calculateAndDisplaySrsProgress(allUserSessions);
            calculateAndDisplayProfileStats(allUserSessions);
            renderQuestionManager();
            populateSetupDropdowns();
            populateAddQuestionForm();
            updateSrsDueCount();
            console.log("[LOG] updateAllDynamicContent: UI refresh complete.");
        }
        
        // --- DASHBOARD & PROFILE ---
        function calculateAndDisplayDashboardStats(sessions) {
            console.log("[LOG] calculateAndDisplayDashboardStats: Calculating dashboard stats.");
            const topicContainer = document.getElementById('db-topic-stats');
            if (!sessions || sessions.length === 0) {
                console.warn("[LOG] calculateAndDisplayDashboardStats: No session data available. Displaying empty state.");
                topicContainer.innerHTML = '<p class="text-slate-500">Noch keine Daten vorhanden. Starte eine Lerneinheit!</p>';
                document.getElementById('db-total-time').textContent = '0m';
                document.getElementById('db-total-questions').textContent = '0';
                document.getElementById('db-avg-score').textContent = '0.0';
                document.getElementById('db-total-followups').textContent = '0';
                return;
            }
            let totalTime = 0, totalQuestions = 0, totalScore = 0, totalFollowUps = 0;
            const topicStats = {};
            sessions.forEach((session) => {
                const topicKey = session.module ? `${session.module} - ${session.topic}` : session.topic;
                if (!topicStats[topicKey]) topicStats[topicKey] = { time: 0, questions: 0, score: 0, followUps: 0, sessions: 0, originalId: session.id };
                const currentTopic = topicStats[topicKey];
                currentTopic.sessions += 1;
                (session.results || []).forEach(res => {
                    totalTime += res.time; totalQuestions++; totalScore += res.score; if (res.hadFollowUp) totalFollowUps++;
                    currentTopic.time += res.time; currentTopic.questions++; currentTopic.score += res.score; if (res.hadFollowUp) currentTopic.followUps++;
                });
            });
            console.log("[LOG] calculateAndDisplayDashboardStats: Calculated totals:", { totalTime, totalQuestions, totalScore, totalFollowUps });
            document.getElementById('db-total-time').textContent = `${Math.round(totalTime / 60)}m`;
            document.getElementById('db-total-questions').textContent = totalQuestions;
            document.getElementById('db-avg-score').textContent = totalQuestions > 0 ? (totalScore / totalQuestions).toFixed(1) : '0.0';
            document.getElementById('db-total-followups').textContent = totalFollowUps;
            
            topicContainer.innerHTML = `<div class="grid grid-cols-5 gap-4 font-semibold text-slate-600 text-sm p-2"><div class="col-span-2">Thema</div><div>√ò Punkte</div><div>Lernzeit</div><div>Nachfragen</div></div>`;
            const sortedTopics = Object.entries(topicStats).sort(([,a],[,b]) => b.time - a.time);
            sortedTopics.forEach(([topic, stats]) => {
                const avgScore = stats.questions > 0 ? (stats.score / stats.questions).toFixed(1) : '0.0';
                const timeMinutes = Math.round(stats.time / 60);
                const topicEl = document.createElement('div');
                topicEl.className = 'grid grid-cols-5 gap-4 items-center p-2 border-t border-slate-100 rounded-md hover:bg-blue-50 cursor-pointer transition-colors';
                topicEl.dataset.sessionId = stats.originalId;
                topicEl.innerHTML = `<div class="col-span-2 font-semibold text-blue-700">${topic}</div><div class="font-mono text-center">${avgScore}</div><div class="font-mono text-center">${timeMinutes} min</div><div class="font-mono text-center">${stats.followUps}</div>`;
                topicContainer.appendChild(topicEl);
            });
             console.log("[LOG] calculateAndDisplayDashboardStats: Dashboard rendering complete.");
        }

        function calculateAndDisplaySrsProgress(sessions) {
            console.log("[LOG] calculateAndDisplaySrsProgress: Calculating SRS progress.");
            const container = document.getElementById('db-srs-progress');
            container.innerHTML = '';
            if (!sessions || sessions.length === 0) {
                container.innerHTML = '<p class="text-slate-500">Keine Daten f√ºr den Lernfortschritt vorhanden.</p>';
                return;
            }

            const maxSrsLevel = SRS_INTERVALS.length - 1;
            const progressByModule = {};

            sessions.forEach(session => {
                if (!session.module || !session.results) return;
                if (!progressByModule[session.module]) {
                    progressByModule[session.module] = { topics: {}, totalCards: 0, maxLevelCards: 0 };
                }

                const topicProgress = {
                    totalCards: session.results.length,
                    maxLevelCards: session.results.filter(r => r.srs && r.srs.level >= maxSrsLevel).length
                };
                topicProgress.percentage = topicProgress.totalCards > 0 ? (topicProgress.maxLevelCards / topicProgress.totalCards) * 100 : 0;
                
                progressByModule[session.module].topics[session.topic] = topicProgress;
                progressByModule[session.module].totalCards += topicProgress.totalCards;
                progressByModule[session.module].maxLevelCards += topicProgress.maxLevelCards;
            });
            console.log("[LOG] calculateAndDisplaySrsProgress: Calculated progress data:", progressByModule);

            Object.keys(progressByModule).sort().forEach(moduleName => {
                const moduleData = progressByModule[moduleName];
                const modulePercentage = moduleData.totalCards > 0 ? (moduleData.maxLevelCards / moduleData.totalCards) * 100 : 0;

                const moduleDetails = document.createElement('details');
                moduleDetails.className = 'bg-slate-50 border border-slate-200 rounded-lg p-4';
                moduleDetails.open = true;

                moduleDetails.innerHTML = `
                    <summary class="text-lg font-semibold text-blue-800">
                        <div class="flex justify-between items-center">
                            <span>${moduleName}</span>
                            <span class="text-sm font-normal text-slate-600">${moduleData.maxLevelCards} / ${moduleData.totalCards} Karten gemeistert</span>
                        </div>
                        <div class="w-full bg-slate-200 rounded-full h-2.5 mt-2">
                            <div class="bg-green-600 h-2.5 rounded-full" style="width: ${modulePercentage.toFixed(2)}%"></div>
                        </div>
                    </summary>
                    <div class="mt-4 pl-4 border-l-2 border-slate-200 space-y-3">
                        ${Object.keys(moduleData.topics).sort().map(topicName => {
                            const topicData = moduleData.topics[topicName];
                            return `
                                <div>
                                    <div class="flex justify-between items-center text-sm font-medium">
                                        <span class="text-slate-700">${topicName}</span>
                                        <span class="text-slate-500">${topicData.maxLevelCards} / ${topicData.totalCards}</span>
                                    </div>
                                    <div class="w-full bg-slate-200 rounded-full h-1.5 mt-1">
                                        <div class="bg-blue-500 h-1.5 rounded-full" style="width: ${topicData.percentage.toFixed(2)}%"></div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                container.appendChild(moduleDetails);
            });
            console.log("[LOG] calculateAndDisplaySrsProgress: SRS progress rendering complete.");
        }
        
        function calculateAndDisplayProfileStats(sessions) {
            console.log("[LOG] calculateAndDisplayProfileStats: Calculating and displaying profile stats.");
            const skillAverages = calculateSkillAverages(sessions);
            renderSkillChart(skillAverages);
        }
        
        function renderSkillChart(data) {
            console.log("[LOG] renderSkillChart: Rendering skill chart with data:", data);
            const ctx = document.getElementById('skill-chart').getContext('2d');
            const chartData = {
                labels: Object.values(SKILL_LABELS),
                datasets: [{
                    label: 'Dein Skill-Level', data: Object.values(data), fill: true,
                    backgroundColor: 'rgba(59, 130, 246, 0.2)', borderColor: 'rgb(59, 130, 246)',
                    pointBackgroundColor: 'rgb(59, 130, 246)', pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff', pointHoverBorderColor: 'rgb(59, 130, 246)'
                }]
            };
            if (skillChartInstance) {
                console.log("[LOG] renderSkillChart: Destroying existing chart instance.");
                skillChartInstance.destroy();
            }
            skillChartInstance = new Chart(ctx, {
                type: 'radar', data: chartData,
                options: {
                    elements: { line: { borderWidth: 3 } },
                    scales: { r: { angleLines: { display: true }, suggestedMin: 0, suggestedMax: 10, pointLabels: { font: { size: 14 } }, ticks: { backdropColor: 'white', stepSize: 2 } } },
                    plugins: { legend: { display: false } }
                }
            });
            console.log("[LOG] renderSkillChart: Chart rendered successfully.");
        }

        async function generateSkillAnalysis() {
            console.log("[LOG] generateSkillAnalysis: Starting skill analysis generation.");
            const analysisBtn = document.getElementById('generate-analysis-btn');
            const outputContainer = document.getElementById('skill-analysis-output');
            toggleButtonLoading(analysisBtn, true);
            outputContainer.classList.remove('hidden');
            outputContainer.innerHTML = '<p class="text-slate-500">KI analysiert dein Profil...</p>';
            try {
                const skillAverages = calculateSkillAverages(allUserSessions);
                const formattedSkills = Object.entries(skillAverages)
                    .map(([key, value]) => `${SKILL_LABELS[key]}: ${value.toFixed(1)}/10`)
                    .join('\n');
                const promptForAnalysis = `User's current skill levels:\n${formattedSkills}`;
                console.log("[LOG] generateSkillAnalysis: Sending prompt to Gemini for analysis:", promptForAnalysis);

                const analysisHTML = await callGemini(promptForAnalysis, 'analysis');
                outputContainer.innerHTML = analysisHTML;
                console.log("[LOG] generateSkillAnalysis: Analysis received and displayed.");
            } catch (error) {
                console.error("[LOG] generateSkillAnalysis: Error generating analysis:", error);
                outputContainer.innerHTML = '<p class="text-red-500">Fehler bei der Analyse.</p>';
            } finally {
                toggleButtonLoading(analysisBtn, false);
            }
        }
        
        // --- QUESTION MANAGEMENT ---
        function renderQuestionManager() {
            console.log("[LOG] renderQuestionManager: Starting to render the question manager.");
            const container = document.getElementById('question-manager');
            container.innerHTML = '';
            if (allUserSessions.length === 0) {
                console.warn("[LOG] renderQuestionManager: No sessions available. Displaying empty state.");
                container.innerHTML = '<p class="text-slate-500">Keine Themen vorhanden. F√ºge oben ein neues Thema hinzu.</p>';
                return;
            }

            const groupedByModule = {};
            allUserSessions.forEach((session) => {
                if (!session.module) return;
                if (!groupedByModule[session.module]) {
                    groupedByModule[session.module] = {};
                }
                if (!groupedByModule[session.module][session.topic]) {
                    groupedByModule[session.module][session.topic] = { questions: [], document: session.document, originalSessionId: session.id };
                }
                (session.results || []).forEach((result, resultIndex) => {
                    groupedByModule[session.module][session.topic].questions.push({
                        ...result,
                        originalSessionId: session.id,
                        originalResultIndex: resultIndex
                    });
                });
            });
            console.log("[LOG] renderQuestionManager: Data grouped by module and topic:", groupedByModule);

            Object.keys(groupedByModule).sort().forEach(moduleName => {
                const moduleDetails = document.createElement('details');
                moduleDetails.className = 'bg-slate-50 border border-slate-200 rounded-lg p-4';
                moduleDetails.open = true;

                const moduleSummary = document.createElement('summary');
                moduleSummary.className = 'text-xl font-semibold text-blue-800';
                moduleSummary.textContent = moduleName;
                moduleDetails.appendChild(moduleSummary);

                const topicsContainer = document.createElement('div');
                topicsContainer.className = 'mt-4 pl-4 space-y-4';

                Object.keys(groupedByModule[moduleName]).sort().forEach(topicName => {
                    const topicData = groupedByModule[moduleName][topicName];
                    const topicDiv = document.createElement('div');
                    
                    let currentDocHTML = `<p class="text-xs text-slate-500 mb-1">Kein Dokument verkn√ºpft.</p>`;
                    if (topicData.document) {
                         currentDocHTML = `
                            <div class="flex items-center text-sm text-slate-600 mb-1 p-2 bg-blue-50 rounded-md">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2 flex-shrink-0"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                                <span class="font-medium flex-grow">${topicData.document.name}</span>
                                <button class="remove-doc-btn p-1 hover:bg-red-200 rounded-full" data-session-id="${topicData.originalSessionId}" title="Dokument entfernen">&times;</button>
                            </div>
                        `;
                    }
                    
                    const documentManagementHTML = `
                        <div class="document-manager p-3 bg-slate-100 rounded-md mt-2 border">
                             <h5 class="text-sm font-semibold mb-2 text-slate-700">Lernmaterial verwalten</h5>
                             ${currentDocHTML}
                             <div class="flex items-center space-x-2">
                                 <input type="file" class="topic-doc-upload block w-full text-sm text-slate-500 file:mr-4 file:py-1 file:px-3 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-100 file:text-blue-700 hover:file:bg-blue-200 cursor-pointer" data-session-id="${topicData.originalSessionId}" accept=".pdf,.docx">
                                 <button class="save-doc-btn bg-blue-600 text-white px-3 py-1 text-sm rounded-md font-semibold hover:bg-blue-700 flex-shrink-0 flex items-center justify-center min-w-[90px]">
                                     <span class="btn-text">Speichern</span>
                                     <div class="loader btn-loader hidden w-4 h-4 border-2 border-white rounded-full"></div>
                                 </button>
                             </div>
                        </div>
                    `;

                    topicDiv.innerHTML = `<h4 class="text-lg font-semibold text-slate-700">${topicName}</h4>`;
                    topicDiv.innerHTML += documentManagementHTML;

                    const questionList = document.createElement('ul');
                    questionList.className = 'space-y-2 mt-3';

                    topicData.questions.forEach(qData => {
                        const li = document.createElement('li');
                        li.className = 'flex items-center justify-between p-3 bg-white rounded-md border';
                        
                        const nextReviewDate = qData.srs ? new Date(qData.srs.nextReview * 1000).toLocaleDateString('de-DE') : 'N/A';
                        const isDue = qData.srs ? qData.srs.nextReview <= (Date.now() / 1000) : true;
                        const srsIndicator = `
                            <span class="text-xs font-mono p-1 rounded ${isDue ? 'bg-yellow-200 text-yellow-800' : 'bg-slate-200 text-slate-600'}" title="N√§chste Wiederholung: ${nextReviewDate}">
                                Lvl ${qData.srs ? qData.srs.level : 0}
                            </span>`;

                        li.innerHTML = `
                            <p class="flex-grow mr-4 text-slate-700">${qData.question}</p>
                            <div class="flex-shrink-0 flex items-center space-x-2">
                                ${srsIndicator}
                                <button class="edit-btn p-2 hover:bg-slate-200 rounded-full" data-session-id="${qData.originalSessionId}" data-result-index="${qData.originalResultIndex}" title="Bearbeiten">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                                </button>
                                <button class="delete-btn p-2 hover:bg-red-200 rounded-full" data-session-id="${qData.originalSessionId}" data-result-index="${qData.originalResultIndex}" title="L√∂schen">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                                </button>
                            </div>
                        `;
                        questionList.appendChild(li);
                    });
                    
                    topicDiv.appendChild(questionList);
                    topicsContainer.appendChild(topicDiv);
                });

                moduleDetails.appendChild(topicsContainer);
                container.appendChild(moduleDetails);
            });
            console.log("[LOG] renderQuestionManager: Rendering complete.");
        }
        
        function handleQuestionEdit(sessionId, resultIndex) {
            console.log(`[LOG] handleQuestionEdit: Editing question. Session ID: ${sessionId}, Result Index: ${resultIndex}.`);
            const questionItem = document.querySelector(`button.edit-btn[data-session-id='${sessionId}'][data-result-index='${resultIndex}']`).closest('li');
            const session = allUserSessions.find(s => s.id === sessionId);
            if (!session || !session.results[resultIndex]) {
                console.error("[LOG] handleQuestionEdit: Session or question not found for editing.");
                return;
            }
            const questionText = session.results[resultIndex].question;
            
            questionItem.innerHTML = `
                <input type="text" value="${questionText}" class="flex-grow mr-4 p-2 border border-blue-400 rounded-md">
                <div class="flex-shrink-0 space-x-2">
                    <button class="save-btn px-4 py-2 bg-green-600 text-white text-sm font-semibold rounded-md hover:bg-green-700" data-session-id="${sessionId}" data-result-index="${resultIndex}">Speichern</button>
                    <button class="cancel-btn px-4 py-2 bg-slate-500 text-white text-sm font-semibold rounded-md hover:bg-slate-600">Abbrechen</button>
                </div>
            `;
        }

        async function handleQuestionSave(sessionId, resultIndex, newText) {
            console.log(`[LOG] handleQuestionSave: Saving question. Session ID: ${sessionId}, Index: ${resultIndex}, New Text: "${newText}".`);
            const session = allUserSessions.find(s => s.id === sessionId);
            if (!session) {
                console.error("[LOG] handleQuestionSave: Session not found.");
                return;
            }
            
            const updatedResults = [...session.results];
            updatedResults[resultIndex].question = newText;
            
            const sessionRef = doc(db, 'users', userId, 'sessions', sessionId);
            try {
                await updateDoc(sessionRef, { results: updatedResults });
                console.log("[LOG] handleQuestionSave: Question updated successfully in Firestore.");
            } catch (error) {
                console.error("[LOG] handleQuestionSave: Error updating question:", error);
                showModal("Fehler beim Speichern der Frage.");
            }
        }

        async function handleQuestionDelete(sessionId, resultIndex) {
            console.log(`[LOG] handleQuestionDelete: Deleting question. Session ID: ${sessionId}, Index: ${resultIndex}.`);
            const session = allUserSessions.find(s => s.id === sessionId);
            if (!session) {
                console.error("[LOG] handleQuestionDelete: Session not found.");
                return;
            }

            const updatedResults = session.results.filter((_, index) => index != resultIndex);
            const sessionRef = doc(db, 'users', userId, 'sessions', sessionId);

            try {
                if (updatedResults.length === 0 && !session.document) {
                    console.log("[LOG] handleQuestionDelete: Last question and no document, deleting entire session document.");
                    await deleteDoc(sessionRef);
                } else {
                    console.log("[LOG] handleQuestionDelete: Updating session with removed question.");
                    await updateDoc(sessionRef, { results: updatedResults });
                }
                 console.log("[LOG] handleQuestionDelete: Deletion successful.");
            } catch (error) {
                console.error("[LOG] handleQuestionDelete: Error deleting question:", error);
                showModal("Fehler beim L√∂schen der Frage.");
            }
        }
        
        async function handleDocumentDelete(sessionId) {
            console.log(`[LOG] handleDocumentDelete: Removing document from session ID: ${sessionId}.`);
            const session = allUserSessions.find(s => s.id === sessionId);
            if (!session) {
                console.error("[LOG] handleDocumentDelete: Session not found.");
                return;
            }

            const sessionRef = doc(db, 'users', userId, 'sessions', sessionId);
            try {
                // Create a new object for the update to remove the 'document' field.
                const updatedSessionData = { ...session };
                delete updatedSessionData.document;
                delete updatedSessionData.id; // Don't save the id back into the document

                if ((session.results || []).length === 0) {
                     console.log("[LOG] handleDocumentDelete: No questions left, deleting entire session document.");
                    await deleteDoc(sessionRef);
                } else {
                    console.log("[LOG] handleDocumentDelete: Removing 'document' field from session.");
                    // Using setDoc to overwrite and remove the field
                    await setDoc(sessionRef, updatedSessionData);
                }
                console.log("[LOG] handleDocumentDelete: Document removal successful.");
            } catch (error) {
                console.error("[LOG] handleDocumentDelete: Error removing document:", error);
                showModal("Fehler beim Entfernen des Dokuments.");
            }
        }

        async function handleSaveDocument(button, sessionId, file) {
            console.log(`[LOG] handleSaveDocument: Saving document for session ID: ${sessionId}. File:`, file);
            if (!file) {
                showModal("Bitte w√§hle zuerst eine Datei aus (.pdf oder .docx).");
                return;
            }
            
            toggleButtonLoading(button, true);
            
            try {
                const reader = new FileReader();
                let extractedText = '';

                const fileReadPromise = new Promise((resolve, reject) => {
                    reader.onload = async (event) => {
                        const arrayBuffer = event.target.result;
                        try {
                            if (file.type === "application/pdf") {
                                console.log("[LOG] handleSaveDocument: Parsing PDF file.");
                                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                                let fullText = '';
                                for (let i = 1; i <= pdf.numPages; i++) {
                                    const page = await pdf.getPage(i);
                                    const textContent = await page.getTextContent();
                                    fullText += textContent.items.map(item => item.str).join(' ') + '\n';
                                }
                                extractedText = fullText;
                            } else if (file.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
                                console.log("[LOG] handleSaveDocument: Parsing DOCX file.");
                                const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                                extractedText = result.value;
                            } else {
                                reject(new Error("Unsupported file type. Please use .pdf or .docx"));
                                return;
                            }
                            console.log(`[LOG] handleSaveDocument: Extracted text length: ${extractedText.length}`);
                            resolve();
                        } catch (parseError) {
                            reject(parseError);
                        }
                    };
                    reader.onerror = (error) => reject(error);
                    reader.readAsArrayBuffer(file);
                });

                await fileReadPromise;

                const newDocument = {
                    name: file.name,
                    content: extractedText
                };

                const sessionRef = doc(db, 'users', userId, 'sessions', sessionId);
                await updateDoc(sessionRef, { document: newDocument });
                console.log("[LOG] handleSaveDocument: Document saved successfully to Firestore.");
                showModal(`Dokument "${file.name}" wurde erfolgreich verarbeitet und gespeichert.`);

            } catch (error) {
                console.error("[LOG] handleSaveDocument: Error processing or saving document:", error);
                showModal(`Fehler beim Verarbeiten des Dokuments: ${error.message}`);
            } finally {
                toggleButtonLoading(button, false);
            }
        }

        async function handleAddQuestions() {
            console.log("[LOG] handleAddQuestions: Attempting to add new questions.");
            const moduleSelect = document.getElementById('add-q-module');
            const topicSelect = document.getElementById('add-q-topic');
            
            let module = moduleSelect.value;
            if (module === 'new_module') {
                module = document.getElementById('add-q-new-module-input').value.trim();
            }
            
            let topic = topicSelect.value;
            if (topic === 'new_topic') {
                topic = document.getElementById('add-q-new-topic-input').value.trim();
            }

            const questionsText = document.getElementById('add-q-textarea').value.trim();
            const questions = questionsText.split('\n').filter(q => q.trim() !== '');
            console.log(`[LOG] handleAddQuestions: Module: '${module}', Topic: '${topic}', Questions count: ${questions.length}`);
            
            if (!module || !topic) {
                showModal("Bitte w√§hle/erstelle ein Modul und ein Thema.");
                return;
            }
            
            if (questions.length === 0) {
                 showModal("Bitte gib mindestens eine Frage ein, um sie hinzuzuf√ºgen.");
                return;
            }

            let session = allUserSessions.find(s => s.module === module && s.topic === topic);
            
            const createNewResult = (qText) => ({
                question: qText, answer: "", score: 0, time: 0, hadFollowUp: false, skill_ratings: {},
                srs: { level: 0, nextReview: Math.floor(Date.now() / 1000) }
            });

            try {
                if (session) {
                    console.log(`[LOG] handleAddQuestions: Found existing session (ID: ${session.id}). Appending questions.`);
                    const newResults = questions.map(createNewResult);
                    const updatedResults = [...(session.results || []), ...newResults];
                    const sessionRef = doc(db, 'users', userId, 'sessions', session.id);
                    await updateDoc(sessionRef, { results: updatedResults });
                } else {
                    console.log("[LOG] handleAddQuestions: No existing session found. Creating a new one.");
                    const newResults = questions.map(createNewResult);
                    const newSession = {
                        module: module, topic: topic, createdAt: { seconds: Math.floor(Date.now() / 1000) }, 
                        results: newResults,
                        document: null
                    };
                    const sessionsCollectionRef = collection(db, 'users', userId, 'sessions');
                    await addDoc(sessionsCollectionRef, newSession);
                }
                console.log("[LOG] handleAddQuestions: Questions saved successfully.");
                document.getElementById('add-q-textarea').value = '';
                showModal(`${questions.length} Frage(n) zum Thema "${topic}" hinzugef√ºgt.`);
            } catch (error) {
                console.error("[LOG] handleAddQuestions: Error saving questions to Firestore:", error);
                showModal("Fehler beim Speichern der Fragen in der Datenbank.");
            }
        }
        
        // --- DROPDOWN & SETUP LOGIC ---
        function extractModulesAndTopics(sessions) {
            console.log("[LOG] extractModulesAndTopics: Extracting structure from sessions.");
            const structuredData = {};
            sessions.forEach(session => {
                if (!session.module || !session.topic) return;
                if (!structuredData[session.module]) {
                    structuredData[session.module] = new Set();
                }
                structuredData[session.module].add(session.topic);
            });
            for (const module in structuredData) {
                structuredData[module] = Array.from(structuredData[module]);
            }
            console.log("[LOG] extractModulesAndTopics: Extracted data:", structuredData);
            return structuredData;
        }

        function populateAddQuestionForm() {
            console.log("[LOG] populateAddQuestionForm: Populating dropdowns in 'Add Question' form.");
            modulesAndTopics = extractModulesAndTopics(allUserSessions);
            const moduleSelect = document.getElementById('add-q-module');
            
            moduleSelect.innerHTML = '<option value="">Modul w√§hlen...</option>';
            Object.keys(modulesAndTopics).sort().forEach(module => {
                moduleSelect.innerHTML += `<option value="${module}">${module}</option>`;
            });
            moduleSelect.innerHTML += '<option value="new_module">Neues Modul erstellen...</option>';
            
            handleAddQModuleChange();
        }

        function handleAddQModuleChange() {
            const moduleSelect = document.getElementById('add-q-module');
            const selectedModule = moduleSelect.value;
            console.log(`[LOG] handleAddQModuleChange: Module changed to '${selectedModule}'.`);
            const topicSelect = document.getElementById('add-q-topic');
            const newModuleInput = document.getElementById('add-q-new-module-input');
            const newTopicInput = document.getElementById('add-q-new-topic-input');
            
            newTopicInput.classList.add('hidden');

            if (selectedModule === 'new_module') {
                newModuleInput.classList.remove('hidden');
                topicSelect.innerHTML = '<option value="new_topic">Neues Thema erstellen...</option>';
                topicSelect.value = 'new_topic';
                newTopicInput.classList.remove('hidden');
            } else if (selectedModule) {
                newModuleInput.classList.add('hidden');
                topicSelect.innerHTML = '<option value="">Thema w√§hlen...</option>';
                if(modulesAndTopics[selectedModule]) {
                    modulesAndTopics[selectedModule].sort().forEach(topic => {
                        topicSelect.innerHTML += `<option value="${topic}">${topic}</option>`;
                    });
                }
                topicSelect.innerHTML += '<option value="new_topic">Neues Thema erstellen...</option>';
            } else {
                newModuleInput.classList.add('hidden');
                topicSelect.innerHTML = '<option value="">Zuerst Modul w√§hlen...</option>';
            }
        }

        function handleAddQTopicChange() {
            const topicSelect = document.getElementById('add-q-topic');
            const newTopicInput = document.getElementById('add-q-new-topic-input');
            const topic = topicSelect.value;
            console.log(`[LOG] handleAddQTopicChange: Topic changed to '${topic}'.`);
            
            if (topic === 'new_topic') {
                newTopicInput.classList.remove('hidden');
            } else {
                newTopicInput.classList.add('hidden');
            }
        }
        
        function populateSetupDropdowns() {
            console.log("[LOG] populateSetupDropdowns: Populating dropdowns in 'Setup' panel.");
            modulesAndTopics = extractModulesAndTopics(allUserSessions);
            const moduleSelect = document.getElementById('session-module');
            
            moduleSelect.innerHTML = '<option value="">Modul w√§hlen...</option>';
            Object.keys(modulesAndTopics).sort().forEach(module => {
                moduleSelect.innerHTML += `<option value="${module}">${module}</option>`;
            });
            
            handleModuleChange();
        }

        function handleModuleChange() {
            const moduleSelect = document.getElementById('session-module');
            const selectedModule = moduleSelect.value;
            console.log(`[LOG] handleModuleChange: Module changed to '${selectedModule}'.`);
            const topicSelect = document.getElementById('session-topic');
            
            if (selectedModule) {
                topicSelect.innerHTML = '<option value="">Thema w√§hlen...</option>';
                if(modulesAndTopics[selectedModule]) {
                    modulesAndTopics[selectedModule].sort().forEach(topic => {
                        topicSelect.innerHTML += `<option value="${topic}">${topic}</option>`;
                    });
                }
            } else {
                topicSelect.innerHTML = '<option value="">Zuerst Modul w√§hlen...</option>';
            }
            document.getElementById('session-question-selection').innerHTML = '<p class="text-slate-500">Bitte w√§hle zuerst ein Thema aus.</p>';
        }

        function handleTopicChange() {
            const module = document.getElementById('session-module').value;
            const topic = document.getElementById('session-topic').value;
            console.log(`[LOG] handleTopicChange: Topic changed to '${topic}' for module '${module}'.`);
            renderQuestionSelector(module, topic);
        }

        function renderQuestionSelector(module, topic) {
            console.log(`[LOG] renderQuestionSelector: Rendering question selector for module '${module}' and topic '${topic}'.`);
            const container = document.getElementById('session-question-selection');
            if (!module || !topic) {
                container.innerHTML = '<p class="text-slate-500">Bitte w√§hle zuerst ein Thema aus.</p>';
                return;
            }

            const session = allUserSessions.find(s => s.module === module && s.topic === topic);
            if (!session || (session.results || []).length === 0) {
                console.warn("[LOG] renderQuestionSelector: No questions found for this topic.");
                container.innerHTML = `<p class="text-slate-500">F√ºr dieses Thema wurden keine Fragen gefunden. F√ºge welche im "Fragen & Dokumente"-Tab hinzu.</p>`;
                return;
            }

            container.innerHTML = `<div class="flex justify-end mb-2"><button id="select-all-q-btn" class="text-sm text-blue-600 hover:underline">Alle ausw√§hlen</button></div>`;
            session.results.forEach((result, index) => {
                const questionId = `q-select-${index}`;
                const item = document.createElement('div');
                item.className = 'flex items-center p-2 rounded-md hover:bg-slate-200';
                item.innerHTML = `
                    <input type="checkbox" id="${questionId}" name="session_question" value="${result.question}" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                    <label for="${questionId}" class="ml-3 block text-sm text-slate-800 cursor-pointer">${result.question}</label>
                `;
                container.appendChild(item);
            });
            console.log(`[LOG] renderQuestionSelector: Rendered ${session.results.length} questions.`);
            
            document.getElementById('select-all-q-btn').addEventListener('click', () => {
                 container.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
            });
        }

        // --- QUIZ & SESSION LOGIC ---
        function startSession() {
            console.log("[LOG] startSession: Starting manual training session.");
            const module = document.getElementById('session-module').value;
            const topic = document.getElementById('session-topic').value;
            
            const selectedCheckboxes = document.querySelectorAll('#session-question-selection input[type="checkbox"]:checked');
            const questions = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (!module || !topic || questions.length === 0) {
                console.warn("[LOG] startSession: Validation failed - module, topic, or questions missing.");
                showModal("Bitte w√§hle ein Modul, ein Thema und mindestens eine Frage f√ºr das Training aus.");
                return;
            }
            
            const originalSession = allUserSessions.find(s => s.module === module && s.topic === topic);

            currentSession = {
                module: module, topic: topic, questions: questions, results: [], currentQuestionIndex: 0,
                documentContent: originalSession && originalSession.document ? originalSession.document.content : null,
                additionalContext: document.getElementById('session-context').value.trim()
            };
            console.log("[LOG] startSession: Session created:", currentSession);

            switchPanel('quiz');
            displayQuestion();
        }

        function displayQuestion() {
            const qIndex = currentSession.currentQuestionIndex;
            const question = currentSession.questions[qIndex];
            console.log(`[LOG] displayQuestion: Displaying question ${qIndex + 1}/${currentSession.questions.length}: "${question}"`);

            document.getElementById('quiz-topic').textContent = `${currentSession.module} - ${currentSession.topic}`;
            document.getElementById('current-q-num').textContent = qIndex + 1;
            document.getElementById('total-q-num').textContent = currentSession.questions.length;
            document.getElementById('quiz-question').textContent = question;

            document.getElementById('user-answer').value = '';
            document.getElementById('feedback-container').classList.add('hidden');
            document.getElementById('next-question-btn').classList.add('hidden');
            document.getElementById('submit-answer-btn').disabled = false;
            
            startTimer();
        }

        async function submitAnswer() {
            const answer = document.getElementById('user-answer').value.trim();
            console.log(`[LOG] submitAnswer: Submitting answer: "${answer}"`);
            if (!answer) {
                showModal("Bitte gib eine Antwort ein.");
                return;
            }
            
            stopTimer();
            const submitBtn = document.getElementById('submit-answer-btn');
            toggleButtonLoading(submitBtn, true);

            try {
                let context = "Kein Kontext vorhanden.";
                const question = currentSession.questions[currentSession.currentQuestionIndex];
                const originalQuestionData = findOriginalQuestion(question);
                if (originalQuestionData && originalQuestionData.session.document) {
                    context = `KONTEXT AUS DOKUMENT: ${originalQuestionData.session.document.content}`;
                }
                if (currentSession.additionalContext) {
                    context += `\n\nZUS√ÑTZLICHE NOTIZEN: ${currentSession.additionalContext}`;
                }
                
                const prompt = `Bewerte die folgende Antwort basierend auf dem Kontext.\n\n${context}\n\nFRAGE: "${question}"\n\nANTWORT: "${answer}"`;
                console.log("[LOG] submitAnswer: Sending prompt to Gemini for feedback.");

                const responseStr = await callGemini(prompt, 'feedback');
                const feedback = JSON.parse(responseStr);
                console.log("[LOG] submitAnswer: Received and parsed feedback:", feedback);

                const result = {
                    question: question,
                    answer: answer, score: feedback.score, time: secondsElapsed,
                    hadFollowUp: !!feedback.follow_up_question, skill_ratings: feedback.skill_ratings
                };
                currentSession.results.push(result);
                
                if (originalQuestionData) {
                    await updateSpacedRepetition(originalQuestionData.session, originalQuestionData.resultIndex, feedback.score);
                }

                document.getElementById('feedback-content').innerHTML = feedback.feedback_html;
                document.getElementById('feedback-container').classList.remove('hidden');
                document.getElementById('next-question-btn').classList.remove('hidden');

            } catch (error) {
                console.error("[LOG] submitAnswer: Error getting feedback:", error);
                document.getElementById('feedback-content').innerHTML = '<p class="text-red-500">Fehler bei der Bewertung der Antwort. √úberpr√ºfe den API-Schl√ºssel und die Konsolenausgabe.</p>';
                document.getElementById('feedback-container').classList.remove('hidden');
                document.getElementById('next-question-btn').classList.remove('hidden');
            } finally {
                toggleButtonLoading(submitBtn, false);
                submitBtn.disabled = true;
            }
        }

        function nextQuestion() {
            currentSession.currentQuestionIndex++;
            if (currentSession.currentQuestionIndex < currentSession.questions.length) {
                console.log("[LOG] nextQuestion: Moving to the next question.");
                displayQuestion();
            } else {
                console.log("[LOG] nextQuestion: All questions answered. Ending session.");
                endSession();
            }
        }

        function endSession() {
            console.log("[LOG] endSession: Session ended. Displaying stats.");
            displaySessionStats(currentSession);
            switchPanel('stats');
        }
        
        function displaySessionStats(session) {
            console.log("[LOG] displaySessionStats: Displaying stats for session:", session);
            document.getElementById('stats-topic').textContent = session.module ? `${session.module} - ${session.topic}` : session.topic;
            
            const totalScore = session.results.reduce((sum, res) => sum + res.score, 0);
            const totalTime = session.results.reduce((sum, res) => sum + res.time, 0);
            const avgScore = session.results.length > 0 ? (totalScore / session.results.length).toFixed(1) : "0.0";
            console.log("[LOG] displaySessionStats: Calculated stats:", { totalScore, totalTime, avgScore });

            document.getElementById('stats-score').textContent = totalScore;
            document.getElementById('stats-time').textContent = `${Math.round(totalTime / 60)}m ${totalTime % 60}s`;
            document.getElementById('stats-avg-score').textContent = avgScore;

            const detailsContainer = document.getElementById('stats-details');
            detailsContainer.innerHTML = '';
            session.results.forEach((res, index) => {
                const detailEl = document.createElement('div');
                detailEl.className = 'p-4 bg-slate-50 rounded-md';
                detailEl.innerHTML = `
                    <p class="font-semibold">${index + 1}. ${res.question}</p>
                    <div class="flex justify-between items-center mt-2 text-sm text-slate-600">
                        <span>Punkte: <span class="font-bold text-blue-600">${res.score}/10</span></span>
                        <span>Zeit: <span class="font-bold">${res.time}s</span></span>
                        <span>KI-Nachfrage: <span class="font-bold">${res.hadFollowUp ? 'Ja' : 'Nein'}</span></span>
                    </div>
                `;
                detailsContainer.appendChild(detailEl);
            });
        }

        function goBackToDashboard() {
            console.log("[LOG] goBackToDashboard: Returning to dashboard.");
            switchPanel('dashboard');
        }

        // --- HELPER & LOGIC FUNCTIONS ---
        function startTimer() {
            console.log("[LOG] startTimer: Timer started.");
            secondsElapsed = 0;
            const timerEl = document.getElementById('timer');
            timerEl.textContent = '00:00';
            timerInterval = setInterval(() => {
                secondsElapsed++;
                const minutes = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
                const seconds = (secondsElapsed % 60).toString().padStart(2, '0');
                timerEl.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopTimer() {
            console.log(`[LOG] stopTimer: Timer stopped after ${secondsElapsed} seconds.`);
            clearInterval(timerInterval);
        }

        function calculateSkillAverages(sessions) {
            console.log("[LOG] calculateSkillAverages: Calculating average skill ratings.");
            const skillTotals = {}; const skillCounts = {};
            Object.keys(SKILL_LABELS).forEach(key => { skillTotals[key] = 0; skillCounts[key] = 0; });
            sessions.forEach(session => {
                (session.results || []).forEach(res => {
                    if (res.skill_ratings && typeof res.skill_ratings === 'object') {
                        Object.entries(res.skill_ratings).forEach(([key, value]) => {
                            if (skillTotals.hasOwnProperty(key)) { skillTotals[key] += value; skillCounts[key]++; }
                        });
                    }
                });
            });
            const skillAverages = {};
            Object.keys(SKILL_LABELS).forEach(key => {
                skillAverages[key] = skillCounts[key] > 0 ? (skillTotals[key] / skillCounts[key]) : 0;
            });
            console.log("[LOG] calculateSkillAverages: Calculated averages:", skillAverages);
            return skillAverages;
        }

        function toggleButtonLoading(button, isLoading) {
            if (!button) {
                console.warn("[LOG] toggleButtonLoading: Button element not found.");
                return;
            }
            console.log(`[LOG] toggleButtonLoading: Setting loading state to ${isLoading} for button:`, button);
            const btnText = button.querySelector('.btn-text');
            const btnLoader = button.querySelector('.btn-loader');
            
            button.disabled = isLoading;
            if (isLoading) {
                if(btnText) btnText.classList.add('hidden');
                if(btnLoader) btnLoader.classList.remove('hidden');
            } else {
                if(btnText) btnText.classList.remove('hidden');
                if(btnLoader) btnLoader.classList.add('hidden');
            }
        }
        
        function showModal(text, title = "Mitteilung") {
            console.log(`[LOG] showModal: Displaying modal. Title: "${title}", Text: "${text}"`);
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-body').innerHTML = `<p>${text}</p>`;
            document.getElementById('modal-footer').classList.remove('hidden');
            panels.modal.classList.remove('hidden');
        }

        function showTopicDetailModal(sessionId) {
            console.log(`[LOG] showTopicDetailModal: Showing details for session ID: ${sessionId}`);
            const session = allUserSessions.find(s => s.id === sessionId);
            if (!session) {
                console.error(`[LOG] showTopicDetailModal: Session with ID ${sessionId} not found.`);
                return;
            }
            
            document.getElementById('modal-title').textContent = `Details: ${session.module} - ${session.topic}`;
            const body = document.getElementById('modal-body');
            body.innerHTML = '';
            
            const detailsContainer = document.createElement('div');
            detailsContainer.className = 'space-y-4';
            (session.results || []).forEach((res, index) => {
                const detailEl = document.createElement('div');
                detailEl.className = 'p-3 bg-slate-50 rounded-md text-sm';
                detailEl.innerHTML = `
                    <p class="font-semibold text-slate-800">${index + 1}. ${res.question}</p>
                    <div class="flex justify-between items-center mt-2 text-slate-600">
                        <span>Punkte: <span class="font-bold text-blue-600">${res.score}/10</span></span>
                        <span>Zeit: <span class="font-bold">${res.time}s</span></span>
                        <span>KI-Nachfrage: <span class="font-bold">${res.hadFollowUp ? 'Ja' : 'Nein'}</span></span>
                    </div>
                `;
                detailsContainer.appendChild(detailEl);
            });
            body.appendChild(detailsContainer);
            document.getElementById('modal-footer').classList.add('hidden');
            panels.modal.classList.remove('hidden');
        }

        function setupSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                console.log("[LOG] setupSpeechRecognition: Speech Recognition API is supported.");
                recognition = new SpeechRecognition();
                recognition.continuous = true; recognition.lang = 'de-DE'; recognition.interimResults = false;
                recognition.onresult = (event) => {
                    const transcript = event.results[event.results.length - 1][0].transcript;
                    console.log("[LOG] SpeechRecognition onresult: Transcript received:", transcript);
                    document.getElementById('user-answer').value += transcript.trim() + ' ';
                };
                recognition.onend = () => {
                    console.log("[LOG] SpeechRecognition onend: Recognition service disconnected.");
                    document.getElementById('speech-btn').classList.remove('mic-active', 'bg-red-400');
                };
            } else {
                console.warn("[LOG] setupSpeechRecognition: Speech Recognition API not supported. Disabling button.");
                document.getElementById('speech-btn').disabled = true;
            }
        }

        // --- SRS Specific Functions ---
        function getDueQuestions() {
            console.log("[LOG] getDueQuestions: Searching for due questions for SRS session.");
            const now = Math.floor(Date.now() / 1000);
            const dueQuestions = [];
            allUserSessions.forEach(session => {
                (session.results || []).forEach(result => {
                    if (!result.srs) { // Initialize SRS data if missing
                         result.srs = { level: 0, nextReview: now };
                    }
                    if (result.srs.nextReview <= now) {
                        dueQuestions.push({
                            ...result,
                            module: session.module,
                            topic: session.topic,
                            documentContent: session.document ? session.document.content : null
                        });
                    }
                });
            });
            console.log(`[LOG] getDueQuestions: Found ${dueQuestions.length} due questions.`);
            return dueQuestions;
        }

        function updateSrsDueCount() {
            const count = getDueQuestions().length;
            console.log(`[LOG] updateSrsDueCount: Updating due count display to ${count}.`);
            document.getElementById('srs-due-count').textContent = count;
        }

        function startIntelligentSession() {
            console.log("[LOG] startIntelligentSession: Starting SRS session.");
            const dueQuestions = getDueQuestions();
            if (dueQuestions.length === 0) {
                console.log("[LOG] startIntelligentSession: No due questions. Aborting session start.");
                showModal("Super!", "Du bist auf dem neuesten Stand. Keine Fragen zur Wiederholung f√§llig.");
                return;
            }

            const questions = dueQuestions.map(q => q.question);
            
            currentSession = {
                module: "Intelligentes Training",
                topic: "F√§llige Fragen",
                questions: questions,
                results: [],
                currentQuestionIndex: 0,
                documentContent: null,
                additionalContext: ""
            };
            console.log("[LOG] startIntelligentSession: Created SRS session with questions:", currentSession);

            switchPanel('quiz');
            displayQuestion();
        }

        function findOriginalQuestion(questionText) {
            console.log(`[LOG] findOriginalQuestion: Searching for original data for question: "${questionText}"`);
            for (const session of allUserSessions) {
                for (let i = 0; i < (session.results || []).length; i++) {
                    if (session.results[i].question === questionText) {
                        console.log(`[LOG] findOriginalQuestion: Found match in session ID ${session.id} at index ${i}.`);
                        return { session: session, resultIndex: i };
                    }
                }
            }
            console.warn(`[LOG] findOriginalQuestion: No match found.`);
            return null;
        }

        async function updateSpacedRepetition(session, resultIndex, score) {
            console.log(`[LOG] updateSpacedRepetition: Updating SRS data for question in session ${session.id}, index ${resultIndex} with score ${score}.`);
            const questionResult = session.results[resultIndex];
            if (!questionResult) {
                console.error("[LOG] updateSpacedRepetition: Question result not found at given index.");
                return;
            }

            if (!questionResult.srs) {
                console.warn("[LOG] updateSpacedRepetition: SRS object missing, initializing it now.");
                questionResult.srs = { level: 0, nextReview: Math.floor(Date.now() / 1000) };
            }

            let currentLevel = questionResult.srs.level;
            
            if (score >= 8) { // Good answer
                currentLevel++;
            } else if (score <= 5) { // Bad answer
                currentLevel = Math.max(0, currentLevel - 2); // Penalize more heavily
            }
            // Medium answers (6-7) keep the same level.

            const intervalDays = SRS_INTERVALS[Math.min(currentLevel, SRS_INTERVALS.length - 1)];
            const nextReviewTimestamp = Math.floor(Date.now() / 1000) + (intervalDays * 86400);

            const updatedResults = [...session.results];
            updatedResults[resultIndex].srs.level = currentLevel;
            updatedResults[resultIndex].srs.nextReview = nextReviewTimestamp;
            
            const sessionRef = doc(db, 'users', userId, 'sessions', session.id);
            try {
                await updateDoc(sessionRef, { results: updatedResults });
                console.log(`[LOG] updateSpacedRepetition: Updated SRS for "${questionResult.question}": New Level ${currentLevel}, Next review in ${intervalDays} days.`);
            } catch (error) {
                console.error("[LOG] updateSpacedRepetition: Error updating SRS data in Firestore:", error);
            }
        }
        
        // --- EVENT LISTENERS ---
        function addInitialEventListeners() {
            console.log("[LOG] addInitialEventListeners: Adding all initial event listeners.");
            document.querySelectorAll('.tab-btn').forEach(button => {
                button.addEventListener('click', () => switchPanel(button.dataset.target.replace('-panel', '')));
            });
            document.getElementById('generate-analysis-btn').addEventListener('click', generateSkillAnalysis);
            document.getElementById('start-session-btn').addEventListener('click', startSession);
            document.getElementById('start-srs-session-btn').addEventListener('click', startIntelligentSession);
            document.getElementById('submit-answer-btn').addEventListener('click', submitAnswer);
            document.getElementById('next-question-btn').addEventListener('click', nextQuestion);
            document.getElementById('back-to-start-btn').addEventListener('click', goBackToDashboard);

            document.getElementById('session-module').addEventListener('change', handleModuleChange);
            document.getElementById('session-topic').addEventListener('change', handleTopicChange);
            
            document.getElementById('add-q-module').addEventListener('change', handleAddQModuleChange);
            document.getElementById('add-q-topic').addEventListener('change', handleAddQTopicChange);
            document.getElementById('add-questions-btn').addEventListener('click', handleAddQuestions);

            const closeModal = () => panels.modal.classList.add('hidden');
            document.getElementById('modal-ok-btn').addEventListener('click', closeModal);
            document.getElementById('modal-close-btn').addEventListener('click', closeModal);
            panels.modal.addEventListener('click', (e) => { if (e.target === panels.modal) closeModal(); });

            document.getElementById('speech-btn').addEventListener('click', () => {
                if (!recognition) return;
                const btn = document.getElementById('speech-btn');
                if (btn.classList.contains('mic-active')) {
                    console.log("[LOG] Speech Button: Stopping recognition.");
                    recognition.stop();
                } else {
                    console.log("[LOG] Speech Button: Starting recognition.");
                    recognition.start();
                    btn.classList.add('mic-active', 'bg-red-400');
                }
            });

            document.getElementById('question-manager').addEventListener('click', (e) => {
                const editBtn = e.target.closest('.edit-btn');
                const deleteBtn = e.target.closest('.delete-btn');
                const saveBtn = e.target.closest('.save-btn');
                const cancelBtn = e.target.closest('.cancel-btn');
                const removeDocBtn = e.target.closest('.remove-doc-btn');
                const saveDocBtn = e.target.closest('.save-doc-btn');

                if (editBtn) {
                    const { sessionId, resultIndex } = editBtn.dataset;
                    handleQuestionEdit(sessionId, resultIndex);
                } else if (deleteBtn) {
                    const { sessionId, resultIndex } = deleteBtn.dataset;
                    handleQuestionDelete(sessionId, resultIndex);
                } else if (saveBtn) {
                    const { sessionId, resultIndex } = saveBtn.dataset;
                    const newText = saveBtn.closest('li').querySelector('input').value.trim();
                    if (newText) handleQuestionSave(sessionId, resultIndex, newText);
                } else if (cancelBtn) {
                    renderQuestionManager(); // Re-render to cancel edit
                } else if (removeDocBtn) {
                    const { sessionId } = removeDocBtn.dataset;
                    handleDocumentDelete(sessionId);
                } else if (saveDocBtn) {
                    const fileInput = saveDocBtn.closest('.document-manager').querySelector('.topic-doc-upload');
                    const file = fileInput.files[0];
                    handleSaveDocument(saveDocBtn, saveDocBtn.closest('.document-manager').querySelector('.topic-doc-upload').dataset.sessionId, file);
                }
            });

            document.getElementById('db-topic-stats').addEventListener('click', (e) => {
                const topicRow = e.target.closest('[data-session-id]');
                if (topicRow) {
                    showTopicDetailModal(topicRow.dataset.sessionId);
                }
            });
        }

        // --- START ---
        initializeAppAndAuth();

    </script>
</body>
</html>
